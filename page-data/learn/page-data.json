{"componentChunkName":"component---src-templates-learn-tsx","path":"/learn/","webpackCompilationHash":"083565da52ab0c33ff41","result":{"data":{"markdownRemark":{"html":"<p>Whether you are an experienced programmer or not, this website is intended for\neveryone who wishes to learn the Prism programming language as soon as possible.</p>\n<p>Note that, this guide is for the prototype version of Prism and doesn't cover\nall of Prism and topics described here are explained in very simple terms -\nterms that might not be used by Prism internally to refer to them.\nSince Prism is currently not yet released to the public, the language can have\ndrastical changes with every iteration and consequently this guide will have to\nchange too. You need to have an open mind if you want to learn Prism in its early\nstage.</p>\n<h2>Hello, world!</h2>\n<p>To print an object in Prism, just write:</p>\n<pre><code class=\"language-prism\">println(\"Hello, World!\")\n</code></pre>\n<h2>Variables and Types</h2>\n<p>Prism is not statically typed. You don't need to declare the type of variable\nwhile declaring it. The Prism interpreter can infer the type based off of the\ntype of the assigned value.</p>\n<p>Prism uses the <code>let</code> keyword to declare variables. And you can reassign values\nto these variables as needed.</p>\n<p>For example, first we declare the variable <code>everything</code> and assign it to <code>42</code>.\nAnd then we can reassign it to <code>\"is possible\"</code>.</p>\n<pre><code class=\"language-prism\">let everything = 42;\neverything = \"is possible\";\n</code></pre>\n<h3>None</h3>\n<p>The <code>None</code> data type is used internally for objects which doesn't have any\nvalue.\nIn some languages, a reference type variable can be declared without providing\nan initial explicit value. In these cases, the variables are usually assigned\n<code>None</code> value. Prism variables can't hold <code>None</code> values. This means that the\nfollowing snippet is invalid:</p>\n<pre><code class=\"language-prism\">let response = null;\n</code></pre>\n<h3>Boolean</h3>\n<p>Boolean is a data type that holds only one bit of information. It can be\neither <code>true</code> or <code>false</code>.</p>\n<p>In the example below, <code>isValid</code> is a boolean variable with the value of <code>true</code>:</p>\n<pre><code class=\"language-prism\">let isValid = true;\n</code></pre>\n<h3>Numbers</h3>\n<p>Prism, currently in the prototype version, only supports one type of number -\nintegers.</p>\n<p>In the example below, <code>count</code> is a variable of assigned an initial value of\n<code>13</code>:</p>\n<pre><code class=\"language-prism\">let count = 13;\n</code></pre>\n<h3>Characters</h3>\n<p>Character is a data type that can only hold one character. Characters in Prism\nare defined with single quotes.</p>\n<pre><code class=\"language-prism\">let hashTag = '#';\n</code></pre>\n<h3>Strings</h3>\n<p>A String in Prism, as with most other languages, is a sequence of characters.\nStrings in Prism are defined with double quotes.</p>\n<pre><code class=\"language-prism\">let language = \"Prism\";\n</code></pre>\n<h3>Lists</h3>\n<p>Lists are very similar to arrays. They can contain any type of Prism data, and\nthey can contain as many elements as you wish. The elements can be any valid\nPrism expression.</p>\n<p>In the example below, <code>magicNumbers</code> is a Prism list that contains both <code>Number</code>\nand <code>String</code> values as well as an expression.</p>\n<pre><code class=\"language-prism\">let magicNumbers = [ 1337, \"0x8BADF00D\", 42, 10 + 3 ];\n</code></pre>\n<p>List elements are indexed from 0 and can be accessed in the same way it's\naccessed in most languages.</p>\n<pre><code class=\"language-prism\">magicNumbers[3]; # 13\n</code></pre>\n<h3>Hash Maps</h3>\n<p>A hash map is a data type that works with keys and values. Each value in a hash\nmap can be accessed using a key, which can be either Boolean, Integer, Character\nor String. This key is hashed to make a hash key and this hash key is what is\nactually mapped to the value. The keys and values can be any valid Prism\nexpression. The only constraint is that the key expression should evaluate to\nany Hashable type - i.e. Boolean, Integer, Character or String.</p>\n<pre><code class=\"language-prism\">let null = \"0x00\";\n\nlet hashTable = {\n    \"pound\": '#',\n    42: \"anything\" + \" &#x26; \" + \"everything\",\n    10 + 3: \"thirteen\",\n    null: 0,\n};\n\nhashTable[\"0x00\"];  # 0\nhashTable[13];      # thirteen\n</code></pre>\n<p>You can add values to the hash map even after you've initialized it and access\nit the same way as before:</p>\n<pre><code class=\"language-prism\">hashTable[\"traction\"] = \"speed\";\nhashTable[\"traction\"];   # speed\n</code></pre>\n<p>And if you try to access a key that doesn't exist, Prism will return <code>None</code> to\nlet you know that no value is mapped to that key:</p>\n<pre><code class=\"language-prism\">hashTable[\"void\"];   # None\n</code></pre>\n<p>One thing to note here is that hash maps are not ordered in the same way you've\ndeclare or initialize it. So, do not rely on their ordering while working with\nthem.</p>\n<h2>Basic Operators</h2>\n<h3>Arithmetic Operators</h3>\n<p>Just as any other programming languages, the addition, subtraction,\nmultiplication, and division operators can be used with numbers.</p>\n<pre><code class=\"language-prism\">println(40 + (5 + 15) * 30 / 10);  # 100\n</code></pre>\n<p>The <code>+</code> operator can be used with <code>String</code>s to concatenate them:</p>\n<pre><code class=\"language-prism\">println(\"Hello, \" + \"world!\");  # Hello, world!\n</code></pre>\n<p>The unary <code>+</code> and <code>-</code> operators can be used to represent positive and negative\nnumbers, respectively. Numbers are, by default, positive.</p>\n<pre><code class=\"language-prism\">println(+42); # 42\nprintln(-13); # -13\n</code></pre>\n<p>These can be used with <code>Boolean</code> values too, since <code>true</code> evaluates to <code>1</code> and\n<code>false</code> evaluates to <code>0</code>.</p>\n<pre><code class=\"language-prism\">println(-true); # -1\nprintln(false); # 0\n</code></pre>\n<h3>Relational Operators</h3>\n<p>As with most other languages, the relational operators are used in Prism to\ncheck the relation between two operands:</p>\n<pre><code class=\"language-prism\">println(13 == 42);  # false\nprintln(13 != 42);  # true\nprintln(13 > 42);   # false\nprintln(13 &#x3C; 42);   # true\nprintln(13 >= 42);  # false\nprintln(13 &#x3C;= 42);  # true\n</code></pre>\n<h3>Logical Operators</h3>\n<p>The unary <code>!</code> operator is used as the negation operator in Prism, as with most\nother languages. It inverts the value (or logical state) of the expression's\ntruthfulness.</p>\n<pre><code class=\"language-prism\">println(!false);    # true\nprintln(!!13);      # true\nprintln(!\"hello\");  # false\n</code></pre>\n<h2>Conditionals</h2>\n<p>Prism currently only features <em>if-else</em> mechanisim for implementing conditional\nlogic.\nIf an expression wrapped in parentheses next to an <code>if</code> keyword evaluates to\n<code>true</code>, then code within that branch (i.e. the immediately-following code that\nis wrapped in curly braces) is executed. Otherwise, the code within the <code>else</code>\nbranch is executed.</p>\n<pre><code class=\"language-prism\">if (choice == 42) {\n    println(\"You've the answer to the ultimate question of life, the universe, and everything\");\n} else {\n    println(\"Keep looking for the answer.\");\n}\n</code></pre>\n<h3>Conditional Expressions</h3>\n<p>Conditional statements are useful for representing stateful logic, but you may\nfind that you repeat yourself when writing them. In the example above, you\nsimply print a <code>String</code> in each branch. To avoid this repetition, Prism offers\nconditional expressions. The last example can be rewritten as follows:</p>\n<pre><code class=\"language-prism\">let outcome = if (choice == 42) {\n    \"You've the answer to the ultimate question of life, the universe, and everything\";\n} else {\n    \"Keep looking for the answer.\";\n};\n\nprintln(outcome);\n</code></pre>\n<p>Implicitly, each conditional branch returns the result of the expression on its\nfinal line, so you don't need to use a return keyword. In this example,\n<code>outcome</code> is assigned an initial value from the result of the if-else\nexpression.</p>\n<p>Prism does not include a traditional <a href=\"https://en.wikipedia.org/wiki/%3F:\">ternary operator</a>,\ninstead favoring the use of conditional expressions.</p>\n<h2>Loops</h2>\n<p>Looping in Prism can be done using the <code>until</code> expression. If you're familiar\nwith other languages, it's similar to the <code>while</code> loop.</p>\n<p>If an expression wrapped in parentheses next to a <code>until</code> keyword evaluates to\n<code>true</code>, then code within that branch (i.e. the immediately-following code that\nis wrapped in curly braces) is executed, until the aforementioned expression\nevaluates to <code>false</code> - then the loop stops and execution goes to the next line.</p>\n<p>The following example will print all odd numbers from <code>1</code> to <code>13</code>.</p>\n<pre><code class=\"language-prism\">let counter = 1;\n\nuntil (counter &#x3C;= 13) {\n    println(counter);\n    counter = counter + 2;\n}\n</code></pre>","frontmatter":{"title":"Learn the Prism programming language","description":"A crash course on Prism. Learn the Prism programming language in a few minutes."},"tableOfContents":"<ul>\n<li><a href=\"//#hello-world\">Hello, world!</a></li>\n<li>\n<p><a href=\"//#variables-and-types\">Variables and Types</a></p>\n<ul>\n<li><a href=\"//#none\">None</a></li>\n<li><a href=\"//#boolean\">Boolean</a></li>\n<li><a href=\"//#numbers\">Numbers</a></li>\n<li><a href=\"//#characters\">Characters</a></li>\n<li><a href=\"//#strings\">Strings</a></li>\n<li><a href=\"//#lists\">Lists</a></li>\n<li><a href=\"//#hash-maps\">Hash Maps</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"//#basic-operators\">Basic Operators</a></p>\n<ul>\n<li><a href=\"//#arithmetic-operators\">Arithmetic Operators</a></li>\n<li><a href=\"//#relational-operators\">Relational Operators</a></li>\n<li><a href=\"//#logical-operators\">Logical Operators</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"//#conditionals\">Conditionals</a></p>\n<ul>\n<li><a href=\"//#conditional-expressions\">Conditional Expressions</a></li>\n</ul>\n</li>\n<li><a href=\"//#loops\">Loops</a></li>\n</ul>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"source":"learn","slug":"/"}}}