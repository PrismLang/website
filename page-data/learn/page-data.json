{"componentChunkName":"component---src-templates-learn-tsx","path":"/learn/","webpackCompilationHash":"74e4ad58d3f07e14acee","result":{"data":{"markdownRemark":{"html":"<p>Whether you are an experienced programmer or not, this website is intended for\neveryone who wishes to learn the Prism programming language as soon as possible.</p>\n<p>Note that, this guide is for the prototype version of Prism and doesn't cover\nall of Prism and topics described here are explained in very simple terms -\nterms that might not be used by Prism internally to refer to them.\nSince Prism is currently not yet released to the public, the language can have\ndrastical changes with every iteration and consequently this guide will have to\nchange too. You need to have an open mind if you want to learn Prism in its early\nstage.</p>\n<h2>Hello, world!</h2>\n<p>To print an object in Prism, just write:</p>\n<pre><code class=\"language-prism\">println(\"Hello, World!\")\n</code></pre>\n<h2>Variables and Types</h2>\n<p>Prism is not statically typed. You don't need to declare the type of variable\nwhile declaring it. The Prism interpreter can infer the type based off of the\ntype of the assigned value.</p>\n<p>Prism uses the <code>let</code> keyword to declare variables. And you can reassign values\nto these variables as needed.</p>\n<p>For example, first we declare the variable <code>everything</code> and assign it to <code>42</code>.\nAnd then we can reassign it to <code>\"is possible\"</code>.</p>\n<pre><code class=\"language-prism\">let everything = 42;\neverything = \"is possible\";\n</code></pre>\n<h3>None</h3>\n<p>The <code>none</code> data type is used for objects which doesn't have any value. A\nvariable can be declared without providing an initial explicit value. In these\ncases, the variables are usually assigned the <code>none</code> value.</p>\n<pre><code class=\"language-prism\">let response = none;\n</code></pre>\n<h3>Boolean</h3>\n<p>Boolean is a data type that holds only one bit of information. It can be\neither <code>true</code> or <code>false</code>.</p>\n<p>In the example below, <code>isValid</code> is a boolean variable with the value of <code>true</code>:</p>\n<pre><code class=\"language-prism\">let isValid = true;\n</code></pre>\n<h3>Numbers</h3>\n<p>Prism, currently in the prototype version, only supports one type of number -\nintegers.</p>\n<p>In the example below, <code>count</code> is a variable of assigned an initial value of\n<code>13</code>:</p>\n<pre><code class=\"language-prism\">let count = 13;\n</code></pre>\n<h3>Rune</h3>\n<p>Rune is a data type that represent unicode codepoints. Runes in Prism are\ndefined with single quotes.</p>\n<pre><code class=\"language-prism\">let hashTag = '#';\n</code></pre>\n<h3>Strings</h3>\n<p>A String in Prism, as with most other languages, is a sequence of characters.\nStrings in Prism are defined with double quotes.</p>\n<pre><code class=\"language-prism\">let language = \"Prism\";\n</code></pre>\n<h3>Lists</h3>\n<p>Lists are very similar to arrays. They can contain any type of Prism data, and\nthey can contain as many elements as you wish. The elements can be any valid\nPrism expression.</p>\n<p>In the example below, <code>magicNumbers</code> is a Prism list that contains both <code>Number</code>\nand <code>String</code> values as well as an expression.</p>\n<pre><code class=\"language-prism\">let magicNumbers = [ 1337, \"0x8BADF00D\", 42, 10 + 3 ];\n</code></pre>\n<p>List elements are indexed from 0 and can be accessed in the same way it's\naccessed in most languages.</p>\n<pre><code class=\"language-prism\">magicNumbers[3]; # 13\n</code></pre>\n<h3>Hash Maps</h3>\n<p>A hash map is a data type that works with keys and values. Each value in a hash\nmap can be accessed using a key, which can be either Boolean, Integer, Rune or\nString. This key is hashed to make a hash key and this hash key is what is\nactually mapped to the value. The keys and values can be any valid Prism\nexpression. The only constraint is that the key expression should evaluate to\nany Hashable type - i.e. Boolean, Integer, Rune or String.</p>\n<pre><code class=\"language-prism\">let null = \"0x00\";\n\nlet hashTable = {\n    \"pound\": '#',\n    42: \"anything\" + \" &#x26; \" + \"everything\",\n    10 + 3: \"thirteen\",\n    null: 0,\n};\n\nhashTable[\"0x00\"];  # 0\nhashTable[13];      # thirteen\n</code></pre>\n<p>You can add values to the hash map even after you've initialized it and access\nit the same way as before:</p>\n<pre><code class=\"language-prism\">hashTable[\"traction\"] = \"speed\";\nhashTable[\"traction\"];   # speed\n</code></pre>\n<p>And if you try to access a key that doesn't exist, Prism will return <code>none</code> to\nlet you know that no value is mapped to that key:</p>\n<pre><code class=\"language-prism\">hashTable[\"void\"];   # none\n</code></pre>\n<p>One thing to note here is that hash maps are not ordered in the same way you've\ndeclare or initialize it. So, do not rely on their ordering while working with\nthem.</p>\n<h2>Basic Operators</h2>\n<h3>Arithmetic Operators</h3>\n<p>Just as any other programming languages, the addition, subtraction,\nmultiplication, and division operators can be used with numbers.</p>\n<pre><code class=\"language-prism\">println(40 + (5 + 15) * 30 / 10);  # 100\n</code></pre>\n<p>The <code>+</code> operator can be used with <code>String</code>s to concatenate them:</p>\n<pre><code class=\"language-prism\">println(\"Hello, \" + \"world!\");  # Hello, world!\n</code></pre>\n<p>The unary <code>+</code> and <code>-</code> operators can be used to represent positive and negative\nnumbers, respectively. Numbers are, by default, positive.</p>\n<pre><code class=\"language-prism\">println(+42); # 42\nprintln(-13); # -13\n</code></pre>\n<p>These can be used with <code>Boolean</code> values too, since <code>true</code> evaluates to <code>1</code> and\n<code>false</code> evaluates to <code>0</code>.</p>\n<pre><code class=\"language-prism\">println(-true); # -1\nprintln(false); # 0\n</code></pre>\n<h3>Relational Operators</h3>\n<p>As with most other languages, the relational operators are used in Prism to\ncheck the relation between two operands:</p>\n<pre><code class=\"language-prism\">println(13 == 42);  # false\nprintln(13 != 42);  # true\nprintln(13 > 42);   # false\nprintln(13 &#x3C; 42);   # true\nprintln(13 >= 42);  # false\nprintln(13 &#x3C;= 42);  # true\n</code></pre>\n<h3>Logical Operators</h3>\n<p>The unary <code>!</code> operator is used as the negation operator in Prism, as with most\nother languages. It inverts the value (or logical state) of the expression's\ntruthfulness.</p>\n<pre><code class=\"language-prism\">println(!false);    # true\nprintln(!!13);      # true\nprintln(!\"hello\");  # false\n</code></pre>\n<h2>Conditionals</h2>\n<p>Prism currently only features <em>if-else</em> mechanisim for implementing conditional\nlogic.\nIf an expression wrapped in parentheses next to an <code>if</code> keyword evaluates to\n<code>true</code>, then code within that branch (i.e. the immediately-following code that\nis wrapped in curly braces) is executed. Otherwise, the code within the <code>else</code>\nbranch is executed.</p>\n<pre><code class=\"language-prism\">if (choice == 42) {\n    println(\"You've the answer to the ultimate question of life, the universe, and everything\");\n} else {\n    println(\"Keep looking for the answer.\");\n}\n</code></pre>\n<h3>Conditional Expressions</h3>\n<p>Conditional statements are useful for representing stateful logic, but you may\nfind that you repeat yourself when writing them. In the example above, you\nsimply print a <code>String</code> in each branch. To avoid this repetition, Prism offers\nconditional expressions. The last example can be rewritten as follows:</p>\n<pre><code class=\"language-prism\">let outcome = if (choice == 42) {\n    \"You've the answer to the ultimate question of life, the universe, and everything\";\n} else {\n    \"Keep looking for the answer.\";\n};\n\nprintln(outcome);\n</code></pre>\n<p>Implicitly, each conditional branch returns the result of the expression on its\nfinal line, so you don't need to use a return keyword. In this example,\n<code>outcome</code> is assigned an initial value from the result of the if-else\nexpression.</p>\n<p>Prism does not include a traditional <a href=\"https://en.wikipedia.org/wiki/%3F:\">ternary operator</a>,\ninstead favoring the use of conditional expressions.</p>\n<h2>Loops</h2>\n<p>No programming language would be complete without some form of\n<abbr title=\"And that's why HTML is not a programming language.\">iteration</abbr>\n(repeated execution of a block of statements) or loops. Prism can iterate\nthrough the <code>until</code> statement. If you're familiar with other languages, it's\nsimilar to the <code>while</code> loop.</p>\n<p>If an expression wrapped in parentheses next to a <code>until</code> keyword evaluates to\n<code>true</code>, then code within that branch (i.e. the immediately-following code that\nis wrapped in curly braces) is executed, until the aforementioned expression\nevaluates to <code>false</code> - then the loop stops and execution goes to the next line.</p>\n<p>The following example will print all odd numbers from <code>1</code> to <code>13</code>.</p>\n<pre><code class=\"language-prism\">let counter = 1;\n\nuntil (counter &#x3C;= 13) {\n    println(counter);\n    counter = counter + 2;\n}\n</code></pre>\n<h2>Functions</h2>\n<p>You can group one or more expressions into a function. Rather than repeating\nthe same series of expressions each time that you need a result, you can wrap\nthe expressions in a function and call that function instead.</p>\n<p>In Prism, a function is an expression. To declare a function, use the <code>func</code>\nkeyword followed by the types of inputs that your function takes, if any, and\nthen assign it to a variable that will be the function name. A function's body\nis where you define expressions that are called when your function is invoked.</p>\n<p>Here's a complete Prism function that returns the absolute value of the passed\nnumber:</p>\n<pre><code class=\"language-prism\">let getAbsolute = func (num) {\n    if (num &#x3C; 0) {\n        return -num;\n    } else {\n        return num;\n    }\n}\n</code></pre>\n<p>The function in the example above has the name <code>getAbsolute</code>. It takes one\n<code>Number</code> as an input. It returns a result of type <code>Number</code>.</p>\n<p>To call a function, use its name, followed by the invocation operator (<code>()</code>)\nwith the arguments it takes as inputs.</p>\n<p>Building on the previous example, the <code>outcome</code> variable is initialized with the\nresult obtained from calling <code>getAbsolute</code> with <code>-13</code> as its arguments.</p>\n<pre><code class=\"language-prism\">let outcome = getAbsolute(-13);\nprintln(outcome);   # 13\n</code></pre>\n<p>When declaring a function, you can specify any number of arguments (or no\narguments at all). In the example above, <code>getAbsolute()</code> takes one argument\nnamed <code>num</code>. Within the function, you can refer to the argument by using its\nname.</p>\n<h3>Simplifying declarations</h3>\n<p><code>getAbsolute()</code> is a fairly simple function. The function checks a condition and\nthen immediately returns. Utilizing the implicit returning of the result of the\nif-else expression contained in the function, we can simplify our function as\nshown in the following example:</p>\n<pre><code class=\"language-prism\">let getAbsolute = func (num) {\n    return if (num &#x3C; 0) {\n        -num;\n    } else {\n        num;\n    }\n}\n</code></pre>\n<p>Implicitly, functions in Prism returns the result of the expression on its\nfinal line, so you don't need to use a return keyword in such situations.\nSo, we can further simplify the function as shown in the example below:</p>\n<pre><code class=\"language-prism\">let getAbsolute = func (num) {\n    if (num &#x3C; 0) {\n        -num;\n    } else {\n        num;\n    }\n}\n</code></pre>\n<h3>Anonymous Functions</h3>\n<p>Not every function needs a name. Some functions are more directly identified by\ntheir inputs and outputs. These functions are called anonymous functions.\nAnonymous functions are generally used as arguments being passed to higher-order\nfunctions (more on that later), or used for constructing the result of a\nhigehr-order function that needs to return a function.</p>\n<pre><code class=\"language-prism\">func (num) {\n    num * 2\n}\n</code></pre>\n<p>You can keep a reference to an anonymous function, using this reference to call\nthe anonymous function later. You can also pass the reference around your\napplication, as with other reference types. It fulfills the same role for the\nfunction type as literals do for other data types.</p>\n<pre><code class=\"language-prism\">let getDouble = func (num) {\n    num * 2\n}\n</code></pre>\n<p>As you might have guessed it by now, named functions in Prism are anonymous\nfunctions bound to an identifier. Functions are literals in Prism.</p>\n<h3>Higher-order Functions</h3>\n<p>Functions that use other functions as arguments or return another function as\nits result are called higher-order functions. Prism functions supports both -\ntaking another function as an argument and returning another function as its\nresult. Therefore, all Prism functions are first-class functions (as it treats\nfunctions as first-class citizens).</p>\n<p>Here's an example of a higher-order function:</p>\n<pre><code class=\"language-prism\">let funcWrapper = func (arg, fun) {\n    fun(arg)\n}\n</code></pre>\n<p>The <code>funcWrapper()</code> function takes two arguments - a literal <code>arg</code> and function\n<code>fun</code> - and returns the result of <code>fun()</code> which takes the <code>arg</code> as its input.</p>\n<p>You can call <code>funcWrapper()</code> by passing a literal and a function, as shown in\nthe following example:</p>\n<pre><code class=\"language-prism\">let outcome = funcWrapper(-42, getAbsolute);\nprintln(outcome);   # 42\n</code></pre>\n<p>In the example above, we call <code>funcWrapper()</code> with the arguments <code>-42</code> and the\n<code>getAbsolute()</code> function we defined previously and the output is assigned to the\n<code>outcome</code> variable.</p>\n<h3>Closures</h3>\n<p>Functions being first-class citizens in Prism, they are able to form closures.\nA closure is the combination of a function and the lexical environment within\nwhich that function was declared. This environment consists of any local\nvariables that were in-scope at the time the closure was created.</p>\n<pre><code class=\"language-prism\">let multiplier = func (C) {\n    func (num) { num * C }\n}\n\nlet multiplySeven = multiplier(7);\nlet multiplyZero = multiplier(0);\n\nprintln(multiplySeven(191));    # 1337\nprintln(multiplyZero(1337));    # 0\n</code></pre>\n<p>In this example, we have defined a function <code>multiplier()</code>, which takes a single\nargument, <code>C</code>, and returns a new anonymous function. The function it returns\ntakes a single argument, <code>num</code>, and returns the multiplication of <code>num</code> and <code>C</code>.</p>\n<p>In essence, <code>multiplier</code> is a function factory â€” it creates functions which can\nmultiply a specific value to their argument. In the above example we use our\nfunction factory to create two new functions â€” one that multiplies <code>7</code> to its\nargument, and one that multiplies <code>0</code>.</p>\n<p><code>multiplySeven</code> &#x26; <code>multiplyZero</code> are both closures. They share the same function\nbody definition, but store different lexical environments. In <code>multiplySeven</code>'s\nlexical environment, <code>C</code> is <code>7</code>, while in the lexical environment for\n<code>multiplyZero</code>, <code>C</code> is <code>0</code>.</p>\n<p>Now, when we call <code>multiplySevel</code> with an argument of <code>191</code>, it multiplies it\nwith the previously stored value <code>7</code> and returns the output <code>1337</code>. Similarly,\n<code>multiplyZero</code> returns <code>0</code>.</p>\n<h3>Immediately Invoked Function Expression</h3>\n<p>If you're familiar with ECMAScript, you might already know this. Essentially, an\nimmediately invoked function expression (or IIFE) is a function that runs as\nsoon as it's defined.</p>\n<p>It can be used to protect against polluting the global environment and\nsimultaneously allow public access to methods while retaining privacy for\nvariables defined within the function.</p>\n<pre><code class=\"language-prism\">func () {\n    # Statements\n}();\n</code></pre>\n<p>It contains two major parts. The first is the anonymous function so that the\nexpressions defined inside the anonymous function doesn't pollute the global\nscope. The second part creates the immediately executing function expression\n<code>()</code> through which Prism will directly interpret the function.</p>\n<p>In the example below, the function becomes a function expression which is\nimmediately executed. The variable within the expression can't be accessed from\noutside it:</p>\n<pre><code class=\"language-prism\">func () {\n    let str = \"I'm untouchable\";\n    print(str);\n}();\n\n# Variable `str` is not accessible from the outside scope\nprint(str); # NameError: `str` is not defined\n</code></pre>\n<p>Assigning the IIFE to a variable stores the function's return value, not the\nfunction definition itself.</p>\n<pre><code class=\"language-prism\">let outcome = func () {\n    let str = \"I'm untouchable!\";\n    return str;\n}();\n\nprint(outcome); # I'm untouchable!\n</code></pre>\n<h2>Built-in Functions</h2>\n<h3><code>append()</code></h3>\n<p>The <code>append</code> function is used to append elements at the end of a <code>list</code>. It\nreturns a new <code>list</code> with the new element appended to it and the original list\nremains unchanged.</p>\n<pre><code class=\"language-prism\">let foods = [ \"Pizza\", \"Burger\" ];\n\nappend(foods, \"Donut\");\nprintln(foods); # [Pizza, Burger]\n\nfoods = append(foods, \"Donut\");\nprintln(foods); # [Pizza, Burger, Donut]\n</code></pre>\n<h3><code>bool()</code></h3>\n<p>The <code>bool</code> function returns the boolean value of the specified data type.</p>\n<pre><code class=\"language-prism\">bool(false)         # false\nbool(0)             # false\nbool(13)            # true\nbool(\"Traction\")    # true\nbool({ \"v\": 0 })    # true\n</code></pre>\n<h3><code>chr()</code></h3>\n<p>The <code>chr</code> function returns a rune representing a character whose Unicode code\npoint is specified. This is the inverse of <code>ord</code>.</p>\n<pre><code class=\"language-prism\">chr(97);    # 'a'\nchr(8364);  # 'â‚¬'\n</code></pre>\n<h3><code>first()</code></h3>\n<p>The <code>first</code> function returns the first element in the specified list. If the\nlist is empty, it returns <code>none</code>.</p>\n<pre><code class=\"language-prism\">first([ 1, 3, 3, 7 ]);  # 1\nfirst([]);              # none\n</code></pre>\n<h3><code>input()</code></h3>\n<p>The <code>input</code> function is used to take single line input from the user's standard\ninput device. When the line with the <code>input()</code> is executed, it waits for the\nuser to give an input and it returns the input from the user as a <code>string</code>.</p>\n<pre><code class=\"language-prism\">>>> input()\nHello, Prism!   # User input\nHello, Prism!   # Return value\n</code></pre>\n<p>If you intend to store the input string, you can assign the <code>input()</code> to a\nvariable and access it as you'd do with any other variables.</p>\n<pre><code>let message = input();  # User input: Hakuna Matata\nprintln(message);       # Hakuna Matata\n</code></pre>\n<p>And if you want the input prompt to be descriptive, you can do it by passing the\nprompt to the <code>input</code> function, as shown in the example below:</p>\n<pre><code class=\"language-prism\">let name = input(\"What's your name? \"); # User input: Traction\nprintln(name);                          # Traction\n</code></pre>\n<h3><code>last()</code></h3>\n<p>The <code>last</code> function returns the last element in the specified list. If the list\nis empty, it returns <code>none</code>.</p>\n<pre><code class=\"language-prism\">last([ 1, 3, 3, 7 ]);   # 7\nlast([]);               # none\n</code></pre>\n<h3><code>len()</code></h3>\n<p>The <code>len</code> function is used to find the number of elements in a lists, pairs in a\nhash map, unicode codepoints in a strings or rune.</p>\n<pre><code class=\"language-prism\">let arraySize = len([ 13, 42 ]);\nprintln(arraySize);             # 2\n\nlet hashSize = len({\n    \"user\": \"Traction\",\n    \"username\": \"k3rn31p4nic\",\n});\nprintln(hashSize);              # 2\n\nlet stringLength = len(\"Starman\");\nprintln(stringLength);          # 7\n\nstringLength = len(\"ðŸ˜‚\");\nprintln(stringLength);          # 3\n\nlen runeLength = len('#');\nprintln(runeLength);            # 1\n\nruneLength = len('â‚¬');\nprintln(runeLength);            # 3\n</code></pre>\n<h3><code>lower()</code></h3>\n<p>The <code>lower</code> function returns the specified string in lowercase.</p>\n<pre><code class=\"language-prism\">lower(\"Traction\");  # \"traction\"\n</code></pre>\n<h3><code>ord()</code></h3>\n<p>The <code>ord</code> function returns an integer representing the Unicode code point of\nthe specified rune or string representing one Unicode character. This is the\ninverse of <code>chr</code>.</p>\n<pre><code class=\"language-prism\">ord('a');   # 97\nord('â‚¬');   # 8364\n</code></pre>\n<h3><code>reverse()</code></h3>\n<p>The <code>reverse</code> function is used to reverse a <code>list</code>. It returns a new <code>list</code> with\nthe elements in reverse order and the original list remains unchanged.</p>\n<pre><code class=\"language-prism\">let leet = [1, 3, 3, 7];\nlet revLeet = reverse(leet);\n\nprint(leet);                    # [1, 3, 3, 7]\nprint(revLeet);                 # [7, 3, 3, 1]\n</code></pre>\n<h3><code>str()</code></h3>\n<p>The <code>str</code> function returns the string representation of the specified object.</p>\n<pre><code class=\"language-prism\">str(13)         # \"13\"\nstr(false)      # \"false\"\nstr('#')        # \"#\"\nstr(\"Traction\") # \"Traction\"\nstr({ \"v\": 0 }) # \"{ v: 0 }\"\n</code></pre>\n<h3><code>sum()</code></h3>\n<p>The <code>sum</code> function returns the sum of all the elements of a number <code>list</code>.</p>\n<pre><code class=\"language-prism\">let numbers = [1000, 7, 30, 300];\nsum(numbers);   # 1337\n</code></pre>\n<h3><code>type()</code></h3>\n<p>The <code>type</code> function returns the data type of the object that's passed as the\nargument, as shown in the example below:</p>\n<pre><code class=\"language-prism\">let dataType = type(\"Don't Panic\");\nprintln(dataType);                  # STRING\n\ndataType = type({\"Cyber\": \"Punk\"});\nprintln(dataType);                  # HASH\n</code></pre>\n<h3><code>upper()</code></h3>\n<p>The <code>upper</code> function returns the specified string in uppercase.</p>\n<pre><code class=\"language-prism\">upper(\"Traction\");  # \"TRACTION\"\n</code></pre>\n<h2>Modules and Packages</h2>\n<p>Every Prism source file is a module. You can <code>import</code> exported objects from any\nmodule and they will be available under the same namespace.</p>\n<pre><code class=\"language-prism\"># moduleOne.prism\nlet id = 13;\nlet user = \"traction\";\nlet Name = user + str(id);\n</code></pre>\n<p>Now you can import <code>moduleOne</code> in any other Prism code and use the exported\nobjects.</p>\n<pre><code class=\"language-prism\">import moduleOne;\n\nprint(moduleOne.Name);   # traction13\nprint(moduleOne.user);   # none\n</code></pre>\n<p>A package is a collection of multiple modules in one directory. You can <code>import</code>\na package and all the exported objects in all the modules in that package will\nbe available under the same namespace. That means, if you've multiple objects\nwith the same name, it'll be overriden by the object that's imported at last in\nthe lexical order of importing the modules.</p>\n<p>If your package directory structure is something like this:</p>\n<pre><code>packageOne/moduleOne.prism\npackageOne/moduleTwo.prism\npackageOne/subPackage/moduleThree.prism\n</code></pre>\n<p>You can import all the modules under <code>packageOne</code> by just importing the package.\nNote that, modules in subdirectories won't be imported. So, in this case, only\n<code>moduleOne</code> and <code>moduleTwo</code> will be imported under the <code>packageOne</code> namespace.\nAnd all the exported objects in those modules can be accessed using the same\nnamespace.</p>\n<pre><code class=\"language-prism\">>>> import packageOne;\n&#x3C;module \"packageOne\">\n>>> packageOne.SomeVar;\n\"SomeValue\"\n</code></pre>\n<p>Any object in a module that has a name binding starting with an uppercase\ncharacter is exported from that module. All the other objects are private to\nthat module. And you can export any number of objects from a module.</p>","frontmatter":{"title":"Learn the Prism programming language","description":"A crash course on Prism. Learn the Prism programming language in a few minutes."},"tableOfContents":"<ul>\n<li><a href=\"//#hello-world\">Hello, world!</a></li>\n<li>\n<p><a href=\"//#variables-and-types\">Variables and Types</a></p>\n<ul>\n<li><a href=\"//#none\">None</a></li>\n<li><a href=\"//#boolean\">Boolean</a></li>\n<li><a href=\"//#numbers\">Numbers</a></li>\n<li><a href=\"//#rune\">Rune</a></li>\n<li><a href=\"//#strings\">Strings</a></li>\n<li><a href=\"//#lists\">Lists</a></li>\n<li><a href=\"//#hash-maps\">Hash Maps</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"//#basic-operators\">Basic Operators</a></p>\n<ul>\n<li><a href=\"//#arithmetic-operators\">Arithmetic Operators</a></li>\n<li><a href=\"//#relational-operators\">Relational Operators</a></li>\n<li><a href=\"//#logical-operators\">Logical Operators</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"//#conditionals\">Conditionals</a></p>\n<ul>\n<li><a href=\"//#conditional-expressions\">Conditional Expressions</a></li>\n</ul>\n</li>\n<li><a href=\"//#loops\">Loops</a></li>\n<li>\n<p><a href=\"//#functions\">Functions</a></p>\n<ul>\n<li><a href=\"//#simplifying-declarations\">Simplifying declarations</a></li>\n<li><a href=\"//#anonymous-functions\">Anonymous Functions</a></li>\n<li><a href=\"//#higher-order-functions\">Higher-order Functions</a></li>\n<li><a href=\"//#closures\">Closures</a></li>\n<li><a href=\"//#immediately-invoked-function-expression\">Immediately Invoked Function Expression</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"//#built-in-functions\">Built-in Functions</a></p>\n<ul>\n<li><a href=\"//#append\">append()</a></li>\n<li><a href=\"//#bool\">bool()</a></li>\n<li><a href=\"//#chr\">chr()</a></li>\n<li><a href=\"//#first\">first()</a></li>\n<li><a href=\"//#input\">input()</a></li>\n<li><a href=\"//#last\">last()</a></li>\n<li><a href=\"//#len\">len()</a></li>\n<li><a href=\"//#lower\">lower()</a></li>\n<li><a href=\"//#ord\">ord()</a></li>\n<li><a href=\"//#reverse\">reverse()</a></li>\n<li><a href=\"//#str\">str()</a></li>\n<li><a href=\"//#sum\">sum()</a></li>\n<li><a href=\"//#type\">type()</a></li>\n<li><a href=\"//#upper\">upper()</a></li>\n</ul>\n</li>\n<li><a href=\"//#modules-and-packages\">Modules and Packages</a></li>\n</ul>"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"source":"learn","slug":"/"}}}